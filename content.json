{"meta":{"title":"Hexo","subtitle":"","description":"","author":"","url":"http://example.com","root":"/"},"pages":[{"title":"course","date":"2022-03-22T03:26:53.000Z","updated":"2022-03-22T03:26:53.311Z","comments":true,"path":"course/index.html","permalink":"http://example.com/course/index.html","excerpt":"","text":""},{"title":"acm","date":"2022-03-20T05:26:33.000Z","updated":"2022-03-20T05:26:34.004Z","comments":true,"path":"acm/index.html","permalink":"http://example.com/acm/index.html","excerpt":"","text":""}],"posts":[{"title":"2021 acm-icpc区域赛(上海)补题笔记","slug":"2021acm-icpc区域赛(上海)补题笔记","date":"2022-03-29T01:30:40.000Z","updated":"2022-03-31T11:42:01.860Z","comments":true,"path":"2022/03/29/2021acm-icpc区域赛(上海)补题笔记/","link":"","permalink":"http://example.com/2022/03/29/2021acm-icpc%E5%8C%BA%E5%9F%9F%E8%B5%9B(%E4%B8%8A%E6%B5%B7)%E8%A1%A5%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"标签链接： ······ CSDN : https://blog.csdn.net/weixin_45924828/article/details/123869176?spm=1001.2014.3001.5502 前言 题目一览 D.Strange_Fractions(签到) 题意 思路 E.Strange_Integerss(签到) 题意 思路 G.Edge Groups（树形dp) 题意 思路 I.Steadily Growing Steam(背包) 题意： 思路： 代码： H.Life is a Game (kruskal重构树+树上倍增) 题意： 思路： 代码 K.Circle of Life(打表+构造) 题意 思路 代码： J.Two Binary Strings Problem（bitset+位运算） 题意： 思路： B.Strange Permutations （生成函数 &#x2F; NTT+容斥） 前言赛前打几场重现赛模拟一下，争取把力所能及的题都补了 yysy，今年大部分赛站卷的程度已经非往年可比的了。。。。 比赛链接：https://ac.nowcoder.com/acm/contest/24872 题目一览签到题：D,E,G,I 铜牌题：H 银牌题：J,K,M 金牌题：B 大概不是我能做的题：A,C,F,L 本场差不多是5题铜，6.5题银，8题金 D.Strange_Fractions(签到)题意 思路初中数学，设 $x &#x3D; \\frac ab $ , 有 $\\frac pq &#x3D; x + \\frac1x$ , 求根公式解出来即可。 E.Strange_Integerss(签到)题意从 n 个数中选出 m 个数使得两两之差绝对值不低于 k ， 要求最⼤化 m 。 1211 23 1 4 1 5 9 2 6 5 3 5 14 思路排序后从⼩到⼤贪⼼选取合法且尽可能接近的数字即可 G.Edge Groups（树形dp)题意 求树分解成若⼲⻓度为2 的路径的⽅案数。 123456771 21 31 74 75 76 7 13 思路很板子的树dp，队友写的，没看。官方题解： ## I.Steadily Growing Steam(背包)题意：题目有点长，大意是： n件物品具有体积 $t_i$ 和价值 $v_i$ ，选出⾄多 $k$ 件物品 将其体积翻倍，然后选出若⼲物品并将其分为 体积和 相同的两堆$S,T$，问选出的物品 价值之和 最⼤是多少。 输入 123454 110 1-5 35 16 1 输出 121 One possible scheme: Double $t_1$ and choose that $S&#x3D;{1},T&#x3D;{3,4}$, where the point number sum are both 2, and the sum of the card values is $10+5+6&#x3D;21$. 思路：很显然是01背包，其实挺签到的，但却把我们卡了一个多钟。 主要是一直在想两个集合怎么相互转移的问题。 后来想到两个集合是可以合并的。 我们假设装进集合S的物品体积为 $+t_i$ , 那么可以假设装进集合T的物品体积为 $-t_i$ ,这样动态转移的终点就会在体积和 $V&#x3D;0$ 处了。 具体地，设 $dp[N][V][K]$ 表示当前在第i个物品 ， 体积和为V，已经将K件物品翻倍。 然后第$i$个物品只会从第 $i-1$ 个物品转移，所以第一维的N可以用滚动数组滚掉，变成 $dp[2][V][K]$. 我们将每个物品拆分成四个： $aa &#x3D; (v_i , t_i)$ ,$bb &#x3D; (v_i ,- t_i) $ $ cc &#x3D; (v_i , 2t_i) , $$ dd &#x3D; (v_i , -2t_i)$ 那么： $dp[i][V][K] &#x3D; max(dp[i][V][K],dp[i\\oplus1][V-aa][j]+v[i])$ $dp[i][V][K] &#x3D; max(dp[i][V][K],dp[i\\oplus1][V-bb][j]+v[i])$ $dp[i][V][K] &#x3D; max(dp[i][V][K],dp[i\\oplus1][V-cc][j-1]+v[i])$ $, K&gt;0$ $dp[i][V][K] &#x3D; max(dp[i][V][K],dp[i\\oplus1][V-dd][j-1]+v[i])$ $,K&gt;0$ 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 111;int dp[2][5555][111];int n,k;int v[N],t[N];signed main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;v[i]&gt;&gt;t[i]; &#125; for(int i=0;i&lt;=5500;i++) for(int j=0;j&lt;=110;j++) dp[0][i][j] = dp[1][i][j] = -1e15; int now = 0,ans = 0; dp[now][2800][0] = 0; for(int i=1;i&lt;=n;i++)&#123; now = now^1; int aa = t[i],bb = -t[i],cc = 2*t[i],dd = -2*t[i]; for(int V=-2600;V&lt;=2600;V++)&#123; for(int j=0;j&lt;=k;j++)&#123; int tmp = V+2800; dp[now][tmp][j] = dp[now^1][tmp][j]; dp[now][tmp][j] = max(dp[now][tmp][j],dp[now^1][tmp-aa][j]+v[i]); dp[now][tmp][j] = max(dp[now][tmp][j],dp[now^1][tmp-bb][j]+v[i]); if(k&gt;0)&#123; dp[now][tmp][j] = max(dp[now][tmp][j],dp[now^1][tmp-cc][j-1]+v[i]); dp[now][tmp][j] = max(dp[now][tmp][j],dp[now^1][tmp-dd][j-1]+v[i]); &#125; ans = max(ans,dp[now][tmp][j]); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; H.Life is a Game (kruskal重构树+树上倍增)题意：⼀张带边权带点权⽆向图。从某点出发，有初始声望。 每第⼀次到达⼀个点将获得点权等值的声望加成。 经过⼀条边需要满⾜边权等值的最低声望限制。 多次给出起点和初始声望，询问能达到的最⼤声望。 思路：铜牌题越来越难了啊。 我们不会kruskal重构树，那天用堆+启发式合并硬搞出来的。 现在补题主要写一写kruskal重构树的解法，毕竟可以离线做这道题。 洛谷上的kruskal重构树：https://www.luogu.com.cn/problem/P7834 （不过洛谷这题加了主席树维护第k大） 其实就是在kruskal的过程中建树： 把边按边权从小到大排序，并查集合并两端点$u,v$ 的同时新建一个节点$tot$ , 节点$tot$连接$u,v$ , 且维护$u,v$点的共同信息 在本题中 ， $tot$ 节点可以维护两个信息 ，$a_u + a_v$ 和 $w(u,v)$ 。 本题的感想是kruskal重构树是一个很好的思路，它用很少的时间和空间维护了并查集的一些关键信息。 样例的重构树长这样： 然后树上倍增维护每个节点的第i级父节点，查询的时候倍增地查就好了。 官方解答： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5+100;struct node&#123; int u; int v; int w; bool operator&lt;(node B) const&#123; return w&lt;B.w; &#125;&#125;e[N&lt;&lt;1];int a[N&lt;&lt;1];int n,m,q;int fa[N&lt;&lt;1];vector&lt;int&gt; g[N&lt;&lt;1];int val[N&lt;&lt;1];int ff[N&lt;&lt;1][22];int tot;int find_fa(int x)&#123; return (fa[x]==x)?fa[x]:fa[x] = find_fa(fa[x]);&#125;void Kruskal()&#123; tot = n; for(int i=1;i&lt;=m;i++)&#123; int u = find_fa(e[i].u),v = find_fa(e[i].v),w = e[i].w; if(find_fa(u)!= find_fa(v))&#123; tot++; val[tot] = w; g[tot].push_back(u); g[tot].push_back(v); g[u].push_back(tot); g[v].push_back(tot); fa[u] = fa[v] = fa[tot] = tot; &#125; &#125;&#125;void dfs(int u,int f)&#123; ff[u][0] = f; for(int i=1;i&lt;=20;i++)&#123; ff[u][i] = ff[ff[u][i-1]][i-1]; &#125; for(auto v:g[u])&#123; if(v==f) continue; dfs(v,u); a[u] += a[v]; &#125;&#125;signed main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],fa[i] = i; for(int i=1;i&lt;=m;i++)&#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; e[i] = &#123;x,y,z&#125;; &#125; sort(e+1,e+1+m); Kruskal(); dfs(tot,0); val[0] = 1e15+7; while(q--)&#123; int u,x; cin&gt;&gt;u&gt;&gt;x; int now = x+a[u]; while(now!=tot)&#123; //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl; bool ok = false; for(int i=20;i&gt;=0;i--)&#123; if(val[ff[u][i]]&lt;=now)&#123; u = ff[u][i]; ok = true; &#125; &#125; if(!ok) break; now = x+a[u]; &#125; cout&lt;&lt;now&lt;&lt;endl; &#125; return 0;&#125; K.Circle of Life(打表+构造)题意 思路找规律题，感觉如果把重构树写完还能剩一些时间的话大概率都能写写这题。。。 把题意模拟出来，然后发现是构造 发现n &#x3D; 6时只有两种解：100110，（另一个忘了） 然后以这两个为主去找规律，发现1001可以作为循环节，然后没了。 代码：1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;string s[4] = &#123;&quot;1001&quot;,&quot;10001&quot;,&quot;100110&quot;,&quot;1001010&quot;&#125;;int main()&#123; ios::sync_with_stdio(false); int n; cin&gt;&gt;n; if(n==2)&#123; cout&lt;&lt;&quot;10&quot;&lt;&lt;endl; &#125; else if(n==3)&#123; cout&lt;&lt;&quot;Unlucky&quot;&lt;&lt;endl; &#125; else if(n&lt;=7)&#123; cout&lt;&lt;s[n-4]&lt;&lt;endl; &#125; else&#123; int tot = (n-4)/4; int res = (n-4)%4; for(int i=0;i&lt;tot;i++) cout&lt;&lt;&quot;1001&quot;; cout&lt;&lt;s[res]&lt;&lt;endl; &#125;&#125; J.Two Binary Strings Problem（bitset+位运算）题意： 输入 123456725110101100081111000011111100 输出 120100000001100 思路：会不会用bitset决定了这题能不能写。。。。 很显然，打暴力的话复杂度是 $O（n^2)$ 对于32位整型INT ， 用bitset通过位运算打暴力的复杂度是 $O(\\frac {n^2}{32})$ 但是细节很多，对着逆十字的代码看了半天才弄明白。。。 把0变成-1，然后维护前缀和$sum[]$ 把前缀和排个序，大的在前面 然后按顺序遍历一遍 于是惊奇的发现，如果前面访问的位置$i$比之后访问的位置$j$小，那么$j$这个位置肯定是不行的 因为既然有 $sum[i] &gt; sum[j]$ 且 $i &lt; j$ 那么就必然存在一个 $k$ ,使得 $sum[j] - sum[j-k] &lt;&#x3D;0$ ,也就是 $[j-k,j]$ 这个区间的0不比1少 所以开一个bitset A ， 把顺序遍历时对应的位置pos标上，代表该位置被访问了。 对于 $b[i] &#x3D; 0$ 的情况，其实就是将$b[i] &#x3D; 1$时的各项取反 那么再开一个bitset one,置为全1 ， 因为二进制数 异或 全1就是取反。 然后一个bitset ans 记录答案，每次遍历时拿bitset A 更新ans. 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50500;char a[N],b[N];int s[N],id[N];bitset&lt;N&gt; A,ans,one;bool cmp(int xx,int yy)&#123; return s[xx]==s[yy]?xx&lt;yy:s[xx]&gt;s[yy];&#125;int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--)&#123; A.reset(),ans.reset(),one.reset(); int n; cin&gt;&gt;n; cin&gt;&gt;(a+1); cin&gt;&gt;(b+1); int tg = n+1; for(int i=1;i&lt;=n;i++) one[i] = 1; id[0] = 0; for(int i=1;i&lt;=n;i++)&#123; s[i] = s[i-1]+((a[i]==&#x27;1&#x27;)?1:-1); id[i] = i; &#125; sort(id,id+1+n,cmp); for(int i=0;i&lt;=n;i++)&#123; int pos = id[i]; if(pos) &#123; if (b[pos] == &#x27;1&#x27;) &#123; ans = ans | (A &gt;&gt; (n - pos)); if (s[pos] &lt;= 0) tg = min(tg, pos + 1); &#125; else &#123; ans = ans | ((A ^ one) &gt;&gt; (n - pos)); if (s[pos] &gt; 0) tg = min(tg, pos + 1); &#125; &#125; A[n-pos] = 1; &#125; for(int i=1;i&lt;=n;i++)&#123; if(ans[i]||i&gt;=tg) cout&lt;&lt;0; else cout&lt;&lt;1; &#125; cout&lt;&lt;endl; &#125;&#125; B.Strange Permutations （生成函数 &#x2F; NTT+容斥）呜呜呜，不会生成函数，不会快速傅里叶变换，不会数论变换 呜呜呜，我怎么什么都不会呀 有空再更吧。。。。","categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"}]},{"title":"整理下网络流1.0","slug":"整理下网络流1.0","date":"2022-03-22T09:47:14.000Z","updated":"2022-03-23T12:30:31.909Z","comments":true,"path":"2022/03/22/整理下网络流1.0/","link":"","permalink":"http://example.com/2022/03/22/%E6%95%B4%E7%90%86%E4%B8%8B%E7%BD%91%E7%BB%9C%E6%B5%811.0/","excerpt":"","text":"P3254 圆桌问题（最大流） 链接 题意 解析 参考代码 P2762 太空飞行计划问题（最小割） 题目链接 题目大意 思路 代码 P2774 方格取数问题（最小割） 题目 解题思路 代 码 P1251 餐巾计划问题（费用流） 题意 思路 代码 后续待更 [toc] 前言再开个坑，这几天打算看看网络流，应该会以洛谷的24题为主，毕竟之前没怎么写过网络流。 P3254 圆桌问题（最大流）链接https://www.luogu.com.cn/problem/P3254 这道基本算裸题了。 题意 输入 #1 1234 54 5 3 53 5 2 6 4 输出 #1 1234511 2 4 51 2 3 4 52 4 51 2 3 4 5 解析每个单位连所有餐桌，边权为 1 源点连单位, 边权为 $r_i$ 餐桌连汇点，边权为 $c_i$ 如图： 至于统计答案，只需要判断单位–桌子之间的边flow是不是 1 就行了 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 333,M = 333;const int maxn = N*M;const int inf = 0x3f3f3f3f;struct E&#123; int to; int nxt; int flow; int cap;&#125;e[maxn&lt;&lt;1];int head[maxn],tot=1;void add_edge(int u,int v,int w)&#123; e[++tot].to = v; e[tot].cap = w; e[tot].flow = 0; e[tot].nxt = head[u]; head[u] = tot;&#125;int Q[maxn];int dep[maxn],cur[maxn],sta[maxn];bool bfs(int s,int t,int n)&#123; int front = 0,tail = 0; memset(dep,-1,sizeof dep); dep[s] = 0; Q[tail++] = s; while(front&lt;tail)&#123; int u = Q[front++]; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v = e[i].to; if(e[i].cap&gt;e[i].flow&amp;&amp;dep[v]==-1)&#123; dep[v] = dep[u]+1; if(v==t) return true; Q[tail++] = v; &#125; &#125; &#125; return false;&#125;int dinic(int s,int t,int n)&#123; int maxflow = 0; while(bfs(s,t,n))&#123; for(int i=0;i&lt;n;i++) cur[i] = head[i]; int u = s,tail = 0; while (cur[s]!=-1)&#123; if(u==t)&#123; int tp = inf; for(int i=tail-1;i&gt;=0;i--) tp = min(tp,e[sta[i]].cap-e[sta[i]].flow); maxflow += tp; for(int i=tail-1;i&gt;=0;i--)&#123; e[sta[i]].flow += tp; e[sta[i]^1].flow -= tp; if(e[sta[i]].cap-e[sta[i]].flow==0) tail = i; &#125; u = e[sta[tail]^1].to; &#125; else if(cur[u]!=-1&amp;&amp;e[cur[u]].cap&gt;e[cur[u]].flow&amp;&amp;dep[u]+1==dep[e[cur[u]].to])&#123; sta[tail++] = cur[u]; u = e[cur[u]].to; &#125; else&#123; while(u!=s&amp;&amp;cur[u]==-1) u = e[sta[--tail]^1].to; cur[u] = e[cur[u]].nxt; &#125; &#125; &#125; return maxflow;&#125;int s,t,n,m;vector&lt;int&gt; a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; memset(head,-1,sizeof head); int x; int sum = 0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;x; sum+=x; a.push_back(x); &#125; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;x; b.push_back(x); &#125; s = 0,t = n+m+1; for(int i=0;i&lt;a.size();i++)&#123; add_edge(s,i+1,a[i]); add_edge(i+1,s,0); &#125; for(int i=0;i&lt;a.size();i++)&#123; for(int j=0;j&lt;b.size();j++)&#123; int u = i+1,v = a.size()+j+1; add_edge(u,v,1); add_edge(v,u,0); &#125; &#125; for(int i=0;i&lt;b.size();i++)&#123; int u = a.size()+i+1; add_edge(u,t,b[i]); add_edge(t,u,0); &#125; int ans = dinic(s,t,t); if(ans==sum)&#123; cout&lt;&lt;1&lt;&lt;endl; for(int u=1;u&lt;=n;u++)&#123; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v = e[i].to; if(v==s) continue; if(e[i].flow) cout&lt;&lt;v-n&lt;&lt;&quot; &quot;; //统计答案 &#125; cout&lt;&lt;endl; &#125; &#125; else&#123; cout&lt;&lt;0&lt;&lt;endl; &#125;&#125; P2762 太空飞行计划问题（最小割）题目链接https://www.luogu.com.cn/problem/P2762 感觉算半个结论题，虽然并不难猜… 题目大意 输入 #1 12342 310 1 225 2 35 6 7 输出 #1 1231 21 2 317 思路最大权闭合子图，最小割的一个应用。 yysy，我也不知道怎么严谨证明…… 引用洛谷评论区大佬的话，“跑最小割相当于选择部分的实验和部分的仪器，剩下的实验和仪器就会被割掉，此时再用实验的总价值减去可能得到的最大值，即为其所要求的答案” 。 我是这样想的： 实验连源点，仪器连汇点，中间设inf ，如下图。（画图时脑子抽了，图里的项目应该是仪器2333） 我们假设实验全都选，看看至少需要多少钱的仪器，作差就是答案。 简单证明一下： 设实验的全集是U ， 有一个不被选择的子集V 。 那么必然存在仪器的某个子集 K仅存在于集合V 中并且有 $value(K)&lt;value(V)$ 。 此时，因为从子集K中流出的流量仅从V 流入 ， 此时从V流出的最大流最多只有 $value(K)$ 做差后就抵消掉了。 （好吧，只能意会一下，具体见证明：https://blog.csdn.net/can919/article/details/77603353） 关于输出路径 对于每一个$c_i$,把它删掉以后再跑一遍最小割，看看和原来的结果是否相差$c_i$，如果是则证明该边必选，然后再根据选的仪器就可以反推回应该选哪些实验。 关于恶心的读入 写这题的时候刚从题解区大佬那里学到了一个神技。（本题最大收获23333333） 一行中输入的整数个数不确定怎么办（读到换行符结束本行）？ 通常的处理方法是 getline(cin,string) 获得一整行，然后手动从string里把每个整数拆出来，或者用stringstream—其实也很麻烦。 但是快读其实是可以处理这个问题的： 1234567891011int read()&#123; char c;int r=0; while (c&lt;&#x27;0&#x27; || c&gt;&#x27;9&#x27;) c=getchar(); while (c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) &#123; r=r*10+c-&#x27;0&#x27;; c=getchar(); &#125; if (c==&#x27;\\n&#x27;) flg= true; // 如果读到&#x27;\\n&#x27; ， 打上标记 return r;&#125; 123456789flg = false; // 一直读，直到读到换行符while (!flg)&#123; int x; x = read(); ll[i].push_back(x); int u = i,v = x+n; maze[u][v] = inf; maze[v][u] = 0;&#125; 代码本来最大流最小割一直用 Dinic 做的，写这题的时候翻板子发现 邻接矩阵实现的SAP 代码比较短，貌似可读性也不错。 所以这题拿 SAP 算法写的 ，然而并不怎么了解板子， 过两天找个大佬学学 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1100;int maze[N][N];int gap[N],dis[N],pre[N],cur[N];const int inf = 0x3f3f3f3f;int flow[N][N];bool flg;int read()&#123; char c;int r=0; while (c&lt;&#x27;0&#x27; || c&gt;&#x27;9&#x27;) c=getchar(); while (c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) &#123; r=r*10+c-&#x27;0&#x27;; c=getchar(); &#125; if (c==&#x27;\\n&#x27;) flg= true; // 如果读到&#x27;\\n&#x27; ， 打上标记 return r;&#125;int sap(int start,int end,int nodenum)&#123; memset(cur,0,sizeof cur); memset(dis,0,sizeof dis); memset(gap,0,sizeof gap); memset(flow,0,sizeof flow); int u = pre[start] = start,maxflow = 0,aug = -1; gap[0] = nodenum; while(dis[start]&lt;nodenum)&#123; loop: for(int v=cur[u];v&lt;nodenum;v++) &#123; if (maze[u][v] - flow[u][v] &amp;&amp; dis[u] == dis[v] + 1) &#123; if (aug == -1 || aug &gt; maze[u][v] - flow[u][v]) aug = maze[u][v] - flow[u][v]; pre[v] = u; u = cur[u] = v; if (v == end) &#123; maxflow += aug; for (u = pre[u]; v != start; v = u, u = pre[u]) &#123; flow[u][v] += aug; flow[v][u] -= aug; &#125; aug = -1; &#125; goto loop; &#125; &#125; int mindis = nodenum - 1; for(int v=0;v&lt;nodenum;v++)&#123; if(maze[u][v]-flow[u][v]&amp;&amp;mindis&gt;dis[v])&#123; cur[u] = v; mindis = dis[v]; &#125; &#125; if((--gap[dis[u]])==0) break; gap[dis[u]=mindis+1]++; u = pre[u]; &#125; return maxflow;&#125;int p[N],a[N];bool vis1[N],vis2[N];vector&lt;int&gt; ll[N];int main()&#123; int n,m; n = read(),m = read(); int s = 0,t = n+m+1; int sum = 0; for(int i=1;i&lt;=n;i++)&#123; p[i] = read(); sum += p[i]; maze[0][i] = p[i]; maze[i][0] = 0; string str; flg = false; // 一直读，直到读到换行符 while (!flg)&#123; int x; x = read(); ll[i].push_back(x); int u = i,v = x+n; maze[u][v] = inf; maze[v][u] = 0; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; a[i] = read(); int u = i+n,v = t; maze[u][v] = a[i]; maze[v][u] = 0; &#125; int all = sap(s,t,t+1); int ans = sum - all; for(int i=1;i&lt;=m;i++)&#123; int u = i+n,v = t; int save = maze[u][v]; // 删边，跑最小割，与原结果对比 maze[u][v] = 0; maze[v][u] = 0; if(all- sap(s,t,t+1)==save)&#123; vis2[i] = true; &#125; maze[u][v] = save; &#125; for(int i=1;i&lt;=n;i++)&#123; bool ok = true; // 如果一个实验所需的仪器都被选上了，那就选这个实验。 for(auto j:ll[i])&#123; if(!vis2[j]) ok = false; &#125; vis1[i] = ok; &#125; for(int i=1;i&lt;=n;i++) if(vis1[i]) cout&lt;&lt;i&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=1;i&lt;=m;i++) if(vis2[i]) cout&lt;&lt;i&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl;&#125; P2774 方格取数问题（最小割）很经典的最小割 ， 去年某不知名比赛遇到一个改版的，当时当作费用流乱搞没写出来2333 题目 输入 #1 12343 31 2 33 2 32 3 1 输出 #1 111 解题思路网格图或矩阵中相邻点的明显特征就是 $i+j$ 的值奇偶性不同。 题意中相邻格子不取，事实上就构成了一个以奇偶区分二分图，奇数格子在一边，偶数格子在另一边： 一边连源点，边权为该点权值 一边连汇点，边权也是该点权值 中间相邻的边相连，权值为inf（避免被割掉） 如下图，这也是上方给出的样例的写法。 根据最大流 &#x3D; 最小割 ， 我们对此图跑最大流后得到的就是我们想要的： 用最小的权值把图切开 “把图切开”，既没有一条从 S–&gt;T 的路径，也就是保证了选取合法（不选取相邻节点） 我发现这个题，或者说运用最小割解题有个很巧妙的地方就是把那些题意上不能割的边赋值为inf 代 码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5050;int maze[N][N];int gap[N],dis[N],pre[N],cur[N];const int inf = 0x3f3f3f3f;int flow[N][N];int mp[111][111];int sap(int start,int end,int nodenum)&#123; memset(cur,0,sizeof cur); memset(dis,0,sizeof dis); memset(gap,0,sizeof gap); memset(flow,0,sizeof flow); int u = pre[start] = start,maxflow = 0,aug = -1; gap[0] = nodenum; while(dis[start]&lt;nodenum)&#123; loop: for(int v=cur[u];v&lt;nodenum;v++) &#123; if (maze[u][v] - flow[u][v] &amp;&amp; dis[u] == dis[v] + 1) &#123; if (aug == -1 || aug &gt; maze[u][v] - flow[u][v]) aug = maze[u][v] - flow[u][v]; pre[v] = u; u = cur[u] = v; if (v == end) &#123; maxflow += aug; for (u = pre[u]; v != start; v = u, u = pre[u]) &#123; flow[u][v] += aug; flow[v][u] -= aug; &#125; aug = -1; &#125; goto loop; &#125; &#125; int mindis = nodenum - 1; for(int v=0;v&lt;nodenum;v++)&#123; if(maze[u][v]-flow[u][v]&amp;&amp;mindis&gt;dis[v])&#123; cur[u] = v; mindis = dis[v]; &#125; &#125; if((--gap[dis[u]])==0) break; gap[dis[u]=mindis+1]++; u = pre[u]; &#125; return maxflow;&#125;vector&lt;pair&lt;int,int&gt;&gt; a,b;int n, m;int cal(pair&lt;int,int&gt; pa)&#123; return (pa.first-1)*m+pa.second; // 把二位坐标映射成一维的&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int sum = 0; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mp[i][j]; sum += mp[i][j]; if ((i + j) &amp; 1) a.push_back(make_pair(i, j)); else b.push_back(make_pair(i, j)); &#125; &#125; int s = 0,t = n*m+1; for(int i=0;i&lt;a.size();i++)&#123; int u = s,v = cal(a[i]); maze[u][v] = mp[a[i].first][a[i].second]; maze[v][u] = 0; for(int j=0;j&lt;b.size();j++)&#123; if(abs(a[i].first-b[j].first)+abs(a[i].second-b[j].second)==1)&#123; //判断是否相邻 u = cal(a[i]),v = cal(b[j]); maze[u][v] = inf; maze[v][u] = 0; &#125; &#125; &#125; for(int i=0;i&lt;b.size();i++)&#123; int u = cal(b[i]),v = t; maze[u][v] = mp[b[i].first][b[i].second]; maze[v][u] = 0; &#125; cout&lt;&lt;sum - sap(s,t,t+1)&lt;&lt;endl;&#125; P1251 餐巾计划问题（费用流）https://www.luogu.com.cn/problem/P1251 题意 输入 #1 12331 7 5 11 2 2 3 1 输出 #1 1134 思路很巧妙的费用流建模。 首先每一天肯定要拆分成早上（开始），晚上（结束）两个时刻。 早上收集干净毛巾，晚上处理旧毛巾 想的时候一直在思考一个问题，怎么同时把洗过的毛巾送到汇点和送到第二天 一开始想每天早上连晚上 ， 然后最后一天早上连汇点 ， 容量为 $\\sum_{i&#x3D;1}^n r_i$ 后来发现行不通，还是会和旧毛巾冲突到。 经题解区提醒，发现可以直接让源点连旧毛巾到每天晚上： 相当于每天早上“用完新毛巾后直接上交汇点统计，到了晚上源点送出相同数量的旧毛巾” 这与每天“用完$r_i$条新毛巾后变为旧毛巾”是等价的 ， 而且避免了上述建模冲突。 具体建模方法 源点连每天早上，容量为$r_i$ ， 费用为$p$ （直接买毛巾 ） 源点连每天晚上，容量为$r_i$ ， 费用为$0$ （早上用掉的旧毛巾，如上述） 每天早上连汇点，容量为$r_i$ ， 费用为$0$ （交到汇点统计答案） 每天晚上连 该天+快洗天数的的早上，容量为$inf$ ， 费用为$f$ （将部分旧毛巾快洗） 每天晚上连 该天+慢洗天数的的早上，容量为$inf$ ， 费用为$p$ （将部分旧毛巾慢洗） 每天晚上连 第二天晚上，容量为$inf$ ， 费用为$0$ （将剩下的旧毛巾留到第二天） 关于快慢洗这里，我们只需要连接对应的那一天就可以，不需要连接后续的每一天。因为洗好的毛巾在那之后哪一天用都一样。 大致如下图 ， 中间快慢洗部分没有全部画出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn= 2e5+100;struct E&#123; int to; int nxt; int flow; int cost; int cap;&#125;e[maxn&lt;&lt;1];const int inf = 1e12+7;int head[maxn],tot;int pre[maxn],dis[maxn];bool vis[maxn];int N;void init(int n)&#123; N = n; tot = 0; memset(head,-1,sizeof head);&#125;void add_edge(int u,int v,int cap,int cost)&#123; e[tot].to = v;e[tot].cap = cap; e[tot].cost = cost;e[tot].flow = 0; e[tot].nxt = head[u];head[u] = tot++; e[tot].to = u;e[tot].cap = 0; e[tot].cost = -cost;e[tot].flow = 0; e[tot].nxt = head[v];head[v] = tot++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt; q; for(int i=0;i&lt;N;i++)&#123; dis[i] = inf; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v = e[i].to; if(e[i].cap&gt;e[i].flow&amp;&amp;dis[v]&gt;dis[u]+e[i].cost)&#123; dis[v] = dis[u]+e[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]==-1) return false; else return true;&#125;int cost_flow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int min = inf; for(int i=pre[t];i!=-1;i=pre[e[i^1].to])&#123; if(min&gt;e[i].cap-e[i].flow) min = e[i].cap - e[i].flow; &#125; for(int i=pre[t];i!=-1;i=pre[e[i^1].to])&#123; e[i].flow += min; e[i^1].flow -= min; cost += e[i].cost*min; &#125; flow += min; &#125; return flow;&#125;int a[maxn];signed main()&#123; int day; cin&gt;&gt;day; for(int i=1;i&lt;=day;i++)&#123; cin&gt;&gt;a[i]; &#125; int p,m,f,n,s; cin&gt;&gt;p&gt;&gt;m&gt;&gt;f&gt;&gt;n&gt;&gt;s; int S = 0,T = 2*day+1; N = T+1; init(N); for(int i=1;i&lt;=day;i++)&#123; int start = i,end = i+day; add_edge(S,start,a[i],p); // 源点连每天早上，容量为ri ， 费用为p （直接买毛巾 ） add_edge(S,end,a[i],0); // 源点连每天晚上，容量为ri ， 费用为0 （早上用掉的旧毛巾） add_edge(start,T,a[i],0); // 每天早上连汇点，容量为ri ， 费用为0 （交到汇点统计答案） if(start+m&lt;=day) add_edge(end,start+m,inf,f); // （将部分旧毛巾快洗） if(start+n&lt;=day) add_edge(end,start+n,inf,s); // （将部分旧毛巾慢洗） if(i!=day) add_edge(end,end+1,inf,0); // （将剩下的旧毛巾留到第二天） &#125; int cost = 0; N = T+1; cost_flow(S,T,cost); cout&lt;&lt;cost&lt;&lt;endl;&#125; 后续待更。。。。。。","categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"}]},{"title":"最近遇到的各种DP 2.0","slug":"最近遇到的各种DP-2.0","date":"2022-03-22T01:58:18.000Z","updated":"2022-03-31T11:28:42.188Z","comments":true,"path":"2022/03/22/最近遇到的各种DP-2.0/","link":"","permalink":"http://example.com/2022/03/22/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8DDP-2.0/","excerpt":"","text":"路径计数2（容斥） 题目链接 题意 思路 代码： 上课了，待更 前言1.0写不下了，开个2.0。依然是记录下最近写过的DP，以中低档题为主。 路径计数2（容斥）题目链接wls的每日一题，容斥板子。 http://oj.daimayuan.top/problem/467 题意 思路$n &#x3D; 10^6$ , 显然我们不能依照$n$来做，考虑根据障碍物$m$进行转移。 我们记录 $dp[i]$ 为 从 位置$（1，1）$到第$ i $个障碍物的合法走法。 记第$i$个障碍物的位置是$(x_i,y_i)$ , 1.当第$i$个障碍物前没有障碍物时，显然有： $dp[i]$ &#x3D; $C_{x_i+y_i-2}^{x_i-1} $ 2.假设第$i$个障碍物前有一个障碍物$j$，那么我们就减去障碍物$j$对答案的贡献： $dp[i]$ &#x3D; $dp[i]$ - $dp[j]$ * (从$j$号障碍物到$i$号障碍物的走法) 即 ： $dp[i]$ &#x3D; $dp[i]$ - $\\sum_{j&#x3D;1}^{i-1}$ $dp[j]$ * $C_{x_i+y_i-x_j-y_j}^{x_i-y_i} $ &#x3D; $C_{x_i+y_i-2}^{x_i-1} $ - $\\sum_{j&#x3D;1}^{i-1}$ $dp[j]$ * $C_{x_i+y_i-x_j-y_j}^{x_i-y_i} $ ( 其中$x_j&lt;&#x3D;x_i$ , $y_j&lt;&#x3D;y_i$ ) 如图 ， $dp[i]$ &#x3D; 总的走法 - 蓝色区域走法*绿色区域走法 我想这个题的时候曾经有一个疑问： “从$j$号障碍物到$i$号障碍物的走法” 这里可能会经过其他障碍物，不会造成重复吗？ 想想其实是不会的，我们假设 $j$ 和 $i$ 中间插着一个障碍物 $z$ ，那么一定不会存在一条 $ j–&gt;z–&gt;i$ 的路线被统计两次，因为$z$会先于$i$被访问，而 $dp[z]$ 中一定不存在经过j的情况。 3.关于答案统计： 这个简单，创造第$n+1$个障碍物在$(n,n)$处 , 答案即 $dp[n+1]$ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 2e6+100;const int M = 3030;const int mod = 1e9+7;int fac[N],inv[N];int dp[M];struct node&#123; int x; int y; bool operator&lt; (node B)const&#123; if(x==B.x) return y&lt;B.y; return x&lt;B.x; &#125;&#125;;vector&lt;node&gt; v;int ksm(int a,int b,int p)&#123; int ans = 1; while(b)&#123; if(b&amp;1) ans = ans*a%p; a = a*a%p; b &gt;&gt;= 1; &#125; return ans%p;&#125;void pre()&#123; const int mx = 2e6; fac[0] = 1; for(int i=1;i&lt;=mx;i++)&#123; fac[i] = fac[i-1]*i%mod; &#125; inv[mx] = ksm(fac[mx],mod-2,mod)%mod; // 逆元 for(int i=mx-1;i&gt;=0;i--)&#123; inv[i] = inv[i+1]*(i+1)%mod; &#125;&#125;int C(int n,int m)&#123; return fac[n]*inv[n-m]%mod*inv[m]%mod; // 组合数&#125;signed main()&#123; ios::sync_with_stdio(false); pre(); // 预处理逆元和累乘 int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; v.push_back(&#123;x,y&#125;); &#125; v.push_back(&#123;n,n&#125;); // 创造第n+1个障碍物在(n,n)处 sort(v.begin(),v.end()); for(int i=0;i&lt;v.size();i++)&#123; node now = v[i]; dp[i] = C(now.x+now.y-2,now.x-1)%mod; &#125; for(int i=0;i&lt;v.size();i++)&#123; node now = v[i]; for(int j=0;j&lt;i;j++)&#123; if(v[j].x&lt;=v[i].x&amp;&amp;v[j].y&lt;=v[i].y)&#123; // 保证j在i前面 node tmp = v[j]; int cnt = C(now.x-tmp.x+now.y-tmp.y,now.y-tmp.y)%mod; dp[i] = (dp[i] - cnt*dp[j]%mod+mod)%mod; &#125; &#125; &#125; cout&lt;&lt;dp[v.size()-1]&lt;&lt;endl;&#125; 上课了，待更……","categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"}]},{"title":"几个基础的最短路和最小生成树问题","slug":"几个基础的最短路和最小生成树问题","date":"2022-03-21T15:09:41.000Z","updated":"2022-03-22T06:07:51.333Z","comments":true,"path":"2022/03/21/几个基础的最短路和最小生成树问题/","link":"","permalink":"http://example.com/2022/03/21/%E5%87%A0%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"最短路 最短路计数 例题 代码 多源最短路问题 例题 代码 待更 前言复习一下最短路和最小生成树，都是一些最基础的应用，稍微整理一下。 最短路最短路计数其实就是询问最短路有多少条。 因为最短路算法（ Dijkstra , sfpa 等等 ) 本身都算是 BFS+贪心的过程，那么我们只需要在松弛一个节点的时候更新它邻接节点的最短路径数目就可以。 目前在节点 u ， 它有一个邻接节点 v ，从 s –&gt; u 的最短路有 ans[u] 条。 若$ dis[v] &gt; dis[u] + e[u][v] $,我们更新$ dis[v] $, 并将$ ans[v] $重置为$ ans[u]$ 。 若$ dis[v] &#x3D; dis[u] + e[u][v] $,我们将 $ ans[v] $ 加上 $ ans[u]$ 。 例题 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6+100;const int mod = 100003;struct E&#123; int to; int nxt; int w;&#125;e[N&lt;&lt;1];int head[N],tot;int n,m;void add_edge(int u,int v,int w)&#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot;&#125;bool vis[N];int dis[N],ans[N];void dijkstra(int s)&#123; memset(dis,0x3f3f3f3f,sizeof dis); priority_queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,s)); dis[s] = 0,ans[s] = 1; while(!q.empty())&#123; pair&lt;int,int&gt; now = q.top(); int u = now.second; q.pop(); if(vis[u]) continue; vis[u] = true; for(int i=head[u];i;i=e[i].nxt)&#123; int v = e[i].to; if(vis[v]) continue; if(dis[v]&gt;dis[u]+e[i].w)&#123; dis[v] = dis[u]+e[i].w; ans[v] = ans[u]; q.push(make_pair(-dis[v],v)); &#125; else if(dis[v]==dis[u]+e[i].w)&#123; ans[v] = (ans[v]+ans[u])%mod; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add_edge(x,y,1); add_edge(y,x,1); &#125; dijkstra(1); for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;endl; &#125; return 0;&#125; 多源最短路问题有两个起点$ a ,b$ ，一个终点 $s$ , 找到一个权值最小的子图，使得 $a $能到 $s$ ，$ b$ 能到$ s $. 简单来说，求 $a,b$ 到 $s$ 的最短路之和，允许路径重叠, 如下图——红色的路径即所求。。 其实这个问题并不难。 我们发现所有的情况下的最短路都可以归结为一种走法，那就是 a , b 先在某中间点 M 汇合（如上图5号点），再从M一起走向S。 因为其他的所有特殊情况其实就是 $M&#x3D;a,M&#x3D;b,M&#x3D;s$ 的情况。 那么问题就变成了对图中的任意一点 $M_i$ , ans &#x3D; min { $dis[a-&gt;M_i] + dis [b-&gt;M_i] + dis[M_i-&gt;s]$ } 对于 $dis[a-&gt;M_i] , dis [b-&gt;M_i] $ ， 我们分别以a,b点为起点跑一遍最短路即可 ， 得到的 $dis_a[],dis_b[]$ 即所求。 对于 $ dis[M_i-&gt;s] $ , 我们构建原图的反图 ，显然，原图中的 $ dis[M_i-&gt;s] $ 就是反图中的 $ dis[s-&gt;M_i] $，因此以 s 为起点跑一遍最短路，得到的$dis_s[]$ 即所求。 ans &#x3D; min { $dis_a[] + dis_b[] + dis_s[]$ } 因为要建反图，写起来代码可能比较长，但反正都是 ctrl c+v 一遍就好。 例题这个模板挺多的，比如最近的一道 leetcode : (感觉我写的好乱啊，呜呜呜~~) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Solution &#123;public: long long dis[2][100100]; long long to[100100]; long long from[100100]; const long long inf = 1e15; map&lt;int,int&gt; mp[100100]; struct E&#123; int to; int nxt; int w; &#125;e[100100&lt;&lt;1],e2[100100&lt;&lt;1]; int head[100100],tot; int head2[100100],tot2; int N; bool vis[100100]; void add_edge(int u,int v,int w)&#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; &#125; void add_edge2(int u,int v,int w)&#123; e2[++tot2].to = v; e2[tot2].w = w; e2[tot2].nxt = head2[u]; head2[u] = tot2; &#125; void dij(int s,int opt)&#123; memset(vis, false,sizeof vis); priority_queue&lt;pair&lt;long long,int&gt;&gt; q; q.push(make_pair(0,s)); dis[opt][s] = 0; while(!q.empty())&#123; pair&lt;long long,int&gt; now = q.top(); q.pop(); int u = now.second; if(vis[u]) continue; vis[u] = true; for(int i=head[u];i;i=e[i].nxt)&#123; int v = e[i].to; int w = e[i].w; if(!vis[v]&amp;&amp;dis[opt][v]&gt;dis[opt][u]+w)&#123; dis[opt][v] = dis[opt][u]+w; q.push(make_pair(-dis[opt][v],v)); &#125; &#125; &#125; &#125; void dij2(int s)&#123; memset(vis, false,sizeof vis); priority_queue&lt;pair&lt;long long ,int&gt;&gt; q; q.push(make_pair(0,s)); to[s] = 0; while(!q.empty())&#123; pair&lt;int,long long&gt; now = q.top(); q.pop(); int u = now.second; if(vis[u]) continue; vis[u] = true; for(int i=head2[u];i;i=e2[i].nxt)&#123; int v = e2[i].to; int w = e2[i].w; if(!vis[v]&amp;&amp;to[v]&gt;to[u]+w)&#123; to[v] = to[u]+w; q.push(make_pair(-to[v],v)); &#125; &#125; &#125; &#125; long long minimumWeight(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int src1, int src2, int dest) &#123; N = n; for(int i=0;i&lt;n;i++)&#123; dis[0][i] = dis[1][i] = inf; to[i] = inf; &#125; for(int i=0;i&lt;edges.size();i++)&#123; vector&lt;int&gt; now = edges[i]; int u = now[0],v = now[1],w = now[2]; if(!mp[u][v]) mp[u][v] = w; else mp[u][v] = min(mp[u][v],w); &#125; for(int i=0;i&lt;edges.size();i++)&#123; vector&lt;int&gt; now = edges[i]; int u = now[0],v = now[1],w = now[2]; if(mp[u][v]!=w) continue; add_edge(u,v,w); add_edge2(v,u,w); &#125; int s1 = src1,s2 = src2,ee = dest; dij(s1,0),dij(s2,1),dij2(ee); for(int i=0;i&lt;n;i++) from[i] = dis[0][i]+dis[1][i]; long long ans = inf; for(int i=0;i&lt;n;i++) ans = min(ans,to[i]+from[i]); return (ans&gt;=inf)?-1:ans; &#125;&#125;ss; 待更……","categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"}]},{"title":"最近遇到的各种DP 1.0","slug":"最近遇到的各种DP-1.0","date":"2022-03-19T13:11:34.000Z","updated":"2022-03-23T09:36:40.057Z","comments":true,"path":"2022/03/19/最近遇到的各种DP-1.0/","link":"","permalink":"http://example.com/2022/03/19/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8DDP-1.0/","excerpt":"","text":"CF82D Two out of Three (巧妙的转移) 题目链接 题意： 思路： 代码： CF533B Work Group（树形dp) 题目链接： 题意： 思路： 代码： CF296B Yaroslav and Two Strings（计数） 题目链接 题意 思路 代码 CF1201D Treasure Hunting（乱搞） 链接 题意 思路 代码 前言全是codeforces上的，1900~2200左右吧，可能会一直更新这个专题。 CF82D Two out of Three (巧妙的转移)题目链接 http://codeforces.com/problemset/problem/82/D https://www.luogu.com.cn/problem/CF82D 题意：（来自洛谷） 一队顾客排在一位收银员前面。他采取这样一个策略：每次，假如队伍有至少两人，就会从前面的前三人（如果有）中选取两位一起收银，所花费的时间为这两人单独收银所需时间的最大值。如果只有两人，那么一起收银；如果只有一人，那么单独收银。请问所需的总时间最少是多少？ $ 1 \\le n \\le 1000 , 1 \\le a_i \\le 10^6 $ Input 1241 2 3 4 Output 12361 23 4 (输出最少总时间和收银方式) 思路：比较巧妙的动态转移。 每次在前3个人里选2个，手推一下可以发现，第$i$轮收银开始时，前$2*i-1$号剩且仅剩一个人在队列中。 也就是说 ， 第i轮收银的前三人编号一定为：$j , 2i , 2i+1 , j \\epsilon [1,2*i-1]$。 我们令 $ dp[i][j] $ 为 第 i 轮 第 j 个人的情况，可得转移方程： $dp[i][j] &#x3D; max(dp[i-1][j],max(t[2i],t[2i+1]))$ 这里得分三种情况讨论，因为是在 $j , i2 , i2+1$ 这三个人中选2个。 设 a &#x3D; 2i , b &#x3D; 2i+1 1.选 a,b $dp[i][j] &#x3D; max(dp[i-1][j],max(t[a],t[b]))$ 2.选 j,a $dp[i][b] &#x3D; max(dp[i-1][j],max(t[j],t[a]))$ 3.选 j,b $dp[i][a] &#x3D; max(dp[i-1][j],max(t[j],t[b]))$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int dp[N][N];struct node&#123; int i; int j; int last;&#125;;node path[N][N];int t[N];int n;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; int m = n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;t[i]; t[++n] = 0; // 最后补一个权值为0的人可以避免奇数特判 memset(dp,0x3f3f3f3f,sizeof dp); dp[1][1] = max(t[2],t[3]),path[1][1] = &#123;2,3,3&#125;; dp[1][2] = max(t[1],t[3]),path[1][2] = &#123;1,3,3&#125;; dp[1][3] = max(t[1],t[2]),path[1][3] = &#123;1,2,3&#125;; // 第1轮：1,2,3 // 第2轮：1,2,3,4,5 // 第i轮的候选人必为 : j , i*2 , i*2+1 (其中 1 &lt;= j &lt;= i*2-1 ) for(int i=2;i&lt;=n/2;i++)&#123; int a = i*2,b = i*2+1; for(int j=1;j&lt;2*i;j++)&#123; if(dp[i-1][j]+max(t[a],t[b])&lt;dp[i][j])&#123; dp[i][j] = dp[i-1][j]+max(t[a],t[b]); path[i][j] = &#123;a,b,j&#125;; // path记录路径 : a,b是当前收银的两个人, j指从j继承过来 &#125; if(dp[i-1][j]+max(t[j],t[a])&lt;dp[i][b])&#123; dp[i][b] = dp[i-1][j]+max(t[j],t[a]); path[i][b] = &#123;j,a,j&#125;; &#125; if(dp[i-1][j]+max(t[j],t[b])&lt;dp[i][a])&#123; dp[i][a] = dp[i-1][j]+max(t[j],t[b]); path[i][a] = &#123;j,b,j&#125;; &#125; &#125; &#125; cout&lt;&lt;dp[n/2][n]&lt;&lt;endl; // 最后一个收银的一定是dp[n/2][n] ， 然后通过上面存好的路径path.last一个一个找回去 stack&lt;pair&lt;int,int&gt;&gt; st; int now = n; for(int i=n/2;i&gt;=1;i--)&#123; st.push(make_pair(path[i][now].i,path[i][now].j)); now = path[i][now].last; &#125; while(!st.empty())&#123; if(st.top().second&gt;m)&#123; cout&lt;&lt;st.top().first&lt;&lt;endl; &#125; else cout&lt;&lt;st.top().first&lt;&lt;&quot; &quot;&lt;&lt;st.top().second&lt;&lt;endl; st.pop(); &#125;&#125; CF533B Work Group（树形dp)题目链接：http://codeforces.com/problemset/problem/533/B https://www.luogu.com.cn/problem/CF533B 题意：公司有n个人，1是总裁，每个人有一个直接上司。每一个人有一个权值$a_i$，要求找一个集合，使集合中所有人权值之和最大。其中每一个人的下属（直接，间接）总数都必须是偶数。输出最大权值。$ 1 \\le n \\le 2*10^5 , 1 \\le a_i \\le 10^5 $ Input 123456787-1 31 21 11 44 54 35 2 Output 117 (输入第一行是n ， 输入第i+1行表示第i个人的直接上司是x，它的权值是y) 思路：蛮简单的一道树形dp，我却做了好久 23333. 一开始没看到间接下属也算 23333. $ dp[N][2] $ ， 表示目前是第i个人，它的子树是 奇数&#x2F;偶数 情况下的合法最优解。 我一开始感觉要再开一维 $ dp[N][2][2] $ , 第3维表示该节点选或不选，但其实没必要，因为在合法情况下奇数必选偶数必不选。 12dp[u][0] = max(dp[v][0]+x0,dp[v][1]+x1);dp[u][1] = max(dp[v][1]+x0,x1+dp[v][0]); 其中$ x_0 &#x3D; dp[u][0] ,x_1 &#x3D; dp[u][1] $ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 2e5+100;struct E&#123; int to; int nxt;&#125;e[N&lt;&lt;1];int head[N],tot;int dp[N][2];int a[N];void add_edge(int u,int v)&#123; e[++tot].nxt = head[u]; e[tot].to = v; head[u] = tot;&#125;int n;void dfs(int u,int f)&#123; dp[u][1] = -0x3f3f3f3f; for(int i=head[u];i;i=e[i].nxt)&#123; int v = e[i].to; if(v==f) continue; dfs(v,u); int x0 = dp[u][0],x1 = dp[u][1]; dp[u][0] = max(dp[v][0]+x0,dp[v][1]+x1); dp[u][1] = max(dp[v][1]+x0,x1+dp[v][0]); &#125; dp[u][1] = max(dp[u][1],dp[u][0]+a[u]); // 这里主要是为了判叶子节点&#125;signed main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; int rt = 0; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x&gt;&gt;a[i]; if(x==-1) rt = i; else&#123; add_edge(i,x); add_edge(x,i); &#125; &#125; dfs(rt,0); cout&lt;&lt;max(dp[rt][1],dp[rt][0])&lt;&lt;endl;&#125; CF296B Yaroslav and Two Strings（计数）题目链接https://codeforces.com/problemset/problem/296/B https://www.luogu.com.cn/problem/CF296B 题意如果两个只包含数字且长度为 n 的字符串 s 和 w 存在两个数字$ 1\\leq i,j\\leq n$，使得$ s_i&lt;w_i,s_j&gt;w_j$，则称 $s$ 和 $w$ 是不可比的。现在给定两个包含数字和问号且长度为 n 的字符串，问有多少种方案使得将所有问号替换成0到9的数字后两个字符串是不可比的？ input 12329009 output 11 input 12321155 output 10 思路考虑 $ dp[N][4] $: 0 : 前面不出现 $s_j&gt;w_j$ 的情况 1 : 前面不出现 $s_j&lt;w_j$ 的情况 2：前面既有 $s_j&gt;w_j$ ，也有 $s_j&lt;w_j$ 的情况 3：前面全是 $ s_j &#x3D; w_j $ 的情况 那么，对于当前第 i 项来说，无论是否存在$’？’$ ， 都可以分为3种情况： $s_i &gt; w_i$ $s_i &#x3D; w_i$ $s_i &lt; w_i$ 此时每个 $dp[i][ ] $可以从$dp[i-1][ ]$中继承过来，最后答案即为$dp[n][2]$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5+100;const int mod = 1e9+7;int dp[N][4];char s[N],w[N];signed main()&#123; ios::sync_with_stdio(false); int n; cin&gt;&gt;n; cin&gt;&gt;(s+1); cin&gt;&gt;(w+1); dp[0][3] = 1; for(int i=1;i&lt;=n;i++)&#123; if(s[i]!=&#x27;?&#x27;&amp;&amp;w[i]!=&#x27;?&#x27;)&#123; if(s[i]&gt;w[i])&#123; dp[i][0] = 0; dp[i][1] = (dp[i-1][1]+dp[i-1][3])%mod; dp[i][2] = (dp[i-1][0]+dp[i-1][2])%mod; dp[i][3] = 0; &#125; else if(s[i]&lt;w[i])&#123; dp[i][0] = (dp[i-1][0]+dp[i-1][3])%mod; dp[i][1] = 0; dp[i][2] = (dp[i-1][2]+dp[i-1][1])%mod; dp[i][3] = 0; &#125; else&#123; dp[i][0] = dp[i-1][0]; dp[i][1] = dp[i-1][1]; dp[i][2] = dp[i-1][2]; dp[i][3] = dp[i-1][3]; &#125; &#125; else if (s[i]==&#x27;?&#x27;&amp;&amp;w[i]!=&#x27;?&#x27;)&#123; int big = &#x27;9&#x27;-w[i]; // big： s&gt;w的情况数， small： s&lt;w的情况数， equal： s=w情况数 int small = w[i]-&#x27;0&#x27;; int equal = 1; dp[i][0] = (small*dp[i-1][3]%mod+(small+equal)*dp[i-1][0]%mod)%mod; dp[i][1] = (big*dp[i-1][3]%mod+(big+equal)*dp[i-1][1]%mod)%mod; dp[i][2] = (10*dp[i-1][2]%mod + small*dp[i-1][1]%mod + big*dp[i-1][0]%mod)%mod; dp[i][3] = equal*dp[i-1][3]%mod; &#125; else if(s[i]!=&#x27;?&#x27;&amp;&amp;w[i]==&#x27;?&#x27;)&#123; int big = s[i]-&#x27;0&#x27;; // big： s&gt;w的情况数， small： s&lt;w的情况数， equal： s=w情况数 int small = &#x27;9&#x27;-s[i]; int equal = 1; dp[i][0] = (small*dp[i-1][3]%mod+(small+equal)*dp[i-1][0]%mod)%mod; dp[i][1] = (big*dp[i-1][3]%mod+(big+equal)*dp[i-1][1]%mod)%mod; dp[i][2] = (10*dp[i-1][2]%mod + small*dp[i-1][1]%mod + big*dp[i-1][0]%mod)%mod; dp[i][3] = equal*dp[i-1][3]%mod; &#125; else&#123; int big = 45,small = 45,equal = 10; //显然，当s[i],w[i]都是“？”，一共100种取法，s&gt;w的45种 s=w的10种 dp[i][0] = (small*dp[i-1][3]%mod+(small+equal)*dp[i-1][0]%mod)%mod; dp[i][1] = (big*dp[i-1][3]%mod+(big+equal)*dp[i-1][1]%mod)%mod; dp[i][2] = (100*dp[i-1][2]%mod + small*dp[i-1][1]%mod + big*dp[i-1][0]%mod)%mod; dp[i][3] = equal*dp[i-1][3]%mod; &#125; &#125; cout&lt;&lt;dp[n][2]%mod&lt;&lt;endl;&#125; CF1201D Treasure Hunting（乱搞）链接https://codeforces.com/problemset/problem/1201/D https://www.luogu.com.cn/problem/CF1201D 题意 ​ 洛谷的中文题面： input 123453 3 3 21 12 13 12 3 output 16 input 123453 5 3 21 22 33 11 5 output 18 样例解释 思路其实思路很简单但是被我写的特别冗杂。 可以把题目理解成一栋楼里有好几条只能向上走的电梯（下面都称作电梯），要求走最少的步数拿到楼里所有的宝藏。 可以发现事实上对于任意一层楼，只有最左的宝藏相邻的两个电梯和最右的宝藏相邻的两个电梯这4个电梯可能被选择。 那么我们只需要一个$dp[N][4]$ , 让第 i 层和第 i-1 层进行一个4*4的暴力转移就行了。 实现上，我们对每层楼的宝藏位置排个序，找到第一个和最后一个宝藏，然后二分查找相邻的两个电梯。 （其实用lower_bound(),upper_bound()就行了） 这样的复杂度是 $O(16nlogn)$的。 代码（怎么我一写代码就写得好乱啊，呜呜呜） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N= 2e5+1000;int dp[N][4];vector&lt;int&gt; v[N];int n,m,k,q;int b[N];const int inf = 1e15;// cal() 计算在i层楼时，我从from位置开始，到to位置结束，吃完该楼所有宝藏的最短路径（这里写的特别冗杂）// 事实上就是在一个数轴上从from开始，到to结束，必须经过begin,end这两点的最短路径int cal(int row,int from,int to)&#123; int begin = v[row][0],end = v[row][v[row].size()-1]; // 第一个和最后一个宝藏 if(from&gt;to) swap(from,to); if(from==-inf||to==inf) return inf; if(begin==end&amp;&amp;from==to) return 2*abs(begin-from); if(begin==end)&#123; if(from&lt;=begin&amp;&amp;begin&lt;=to) return abs(from-to); else if(begin&lt;=from) return to - begin + from - begin; else return begin-from + begin - to; &#125; if(from&lt;=begin&amp;&amp;end&lt;=to)&#123; return to-from; &#125; if(from&gt;=begin&amp;&amp;to&lt;=end)&#123; return (to-from)+2*abs(from-begin)+2*abs(end-to); &#125; if(from&gt;=begin)&#123; return (to-from)+2*abs(from-begin); &#125; if(to&lt;=end)&#123; return (to-from)+2*abs(end-to); &#125;&#125;// 二分查找第一个位置小于等于now的电梯int small(int now)&#123; int l = 0,r = q+1; int ans = l; while(l&lt;=r)&#123; int mid = (l+r)&gt;&gt;1; if(b[mid]&gt;now)&#123; r = mid-1; &#125; else&#123; ans = mid; l = mid+1; &#125; &#125; return ans;&#125;// 二分查找第一个位置大于等于now的电梯int big(int now)&#123; int l = 0,r = q+1; int ans = r; while(l&lt;=r)&#123; int mid = (l+r)&gt;&gt;1; if(b[mid]&gt;now)&#123; ans = mid; r = mid-1; &#125; else&#123; l = mid+1; &#125; &#125; return ans;&#125;signed main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q; v[1].push_back(1); for(int i=1;i&lt;=k;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; v[x].push_back(y); // 第x层楼有个宝藏y &#125; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;4;j++) dp[i][j] = inf; &#125; int mx = n; for(int i=n;i&gt;=1;i--)&#123; if(!v[i].empty()) break; mx--; &#125; for(int i=1;i&lt;=q;i++) cin&gt;&gt;b[i]; b[0] = -inf;b[q+1] = inf; // 加两个电梯在正负无穷，避免二分时出锅 sort(b,b+q+2); // 给电梯从左到右排个序 for(int i=1;i&lt;=n;i++)&#123; if(v[i].empty()) continue; sort(v[i].begin(),v[i].end()); // 给每层楼的宝藏排序 &#125; int from[4] = &#123;1,1,1,1&#125;; // from[] 记录上一层楼使用的4个电梯位置 dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 0; for(int i=1;i&lt;=n;i++)&#123; if(v[i].empty())&#123; for(int j=0;j&lt;4;j++) dp[i][j] = dp[i-1][j]; // 如果当前楼层没有宝藏，那显然我们直接坐电梯上去就好 continue; &#125; int sa = small(v[i][0]); // 最左宝藏左边的电梯号 int sb = big(v[i][0]); // 最左宝藏右边的电梯号 int sc = small(v[i][v[i].size()-1]); // 最右宝藏左边的电梯号 int sd = big(v[i][v[i].size()-1]); // 最右宝藏左边的电梯号 int to[4] = &#123;b[sa],b[sb],b[sc],b[sd]&#125;; // to [] 这层楼使用的4个电梯位置 // 这里要非常注意，到达顶层以后，到最后一个宝藏就可以停下来了，所以顶层的to[] 不再是电梯位置,而是左右两个宝藏的位置 if(i==mx) to[0] = v[i][0],to[1] = v[i][v[i].size()-1]; for(int j=0;j&lt;4;j++)&#123; for(int z=0;z&lt;4;z++)&#123; // cal() 计算在i层楼时，我从from[z]位置开始，到to[j]位置结束，吃完该楼所有宝藏的最短路径 int ans = cal(i,from[z],to[j]); dp[i][j] = min(dp[i][j],dp[i-1][z]+ans); &#125; &#125; for(int j=0;j&lt;4;j++) from[j] = to[j]; // 把 from 更新成 to &#125; int ans = inf; for(int i=0;i&lt;4;i++) ans = min(ans,dp[n][i]); cout&lt;&lt;ans+(mx-1)&lt;&lt;endl; // 别忘了向上走也算1步 return 0;&#125;","categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-19T09:30:03.235Z","updated":"2022-03-19T09:30:03.236Z","comments":true,"path":"2022/03/19/hello-world/","link":"","permalink":"http://example.com/2022/03/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"你好呀","slug":"我的第一篇博客","date":"2022-03-18T16:00:00.000Z","updated":"2022-03-22T06:08:11.271Z","comments":true,"path":"2022/03/19/我的第一篇博客/","link":"","permalink":"http://example.com/2022/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言hello world ! 终于把博客搭好了，可能以后很长一段时间都会在这里写东西吧 , 希望能一直坚持下去。 唔 ， 马上区域赛了 ， 最近先随便写点 $acm-icpc$ 相关的。 接下来可能整理一些课内的东西，然后再整理一些自己感兴趣的东西。 其他的以后再说吧 ~ ~ OK， let’s begin!","categories":[],"tags":[{"name":"init","slug":"init","permalink":"http://example.com/tags/init/"}]}],"categories":[],"tags":[{"name":"acm","slug":"acm","permalink":"http://example.com/tags/acm/"},{"name":"init","slug":"init","permalink":"http://example.com/tags/init/"}]}